#define STR_LENGTH 100
#include<stdio.h>
#include<conio.h>
#include<string.h>
exec sql include sqlca;

exec sql begin declare section;
char uid[250];
float sal;
int id;
char emp_name[20];
exec sql end declare section;



void main() {
  strcpy(uid,"system/tiger123");
 
  EXEC SQL connect :uid;
  if(sqlca.sqlcode)
    {
      printf("Error during commit, commit not completed.\n");
      printf("   Oracle error %d.\n", sqlca.sqlcode);
      printf("   %s\n", sqlca.sqlerrm.sqlerrmc);
     
    }else {

   printf("Connected the Database\n");
  EXEC SQL select first_name,salary into :emp_name,:sal from employees where employee_id=100;
  printf("Name is %s and salary is %f\n",emp_name,sal);
  }
  getch();	
}


void addEmp() {
	printf("Enter the id\n");
	scanf("%d",&id);
	printf("Enter the name\n");
	scanf("%s",&emp_name);
	printf("Enter the salary\n");
	scanf("%f",&sal);

	EXEC SQL insert into emp values(:id,:emp_name,:sal);
	EXEC SQL COMMIT WORK RELEASE;
	printf("Record inserted successsfully");
}


void insertArrayData() {
int count,i;
printf("How many data do you want to store \n");
scanf("%d",&count);
	printf("Enter the record one by one\n");
	for(i=0;i<count;i++){
	printf("Enter the id\n");
	scanf("%d",&array_id[i]);
	printf("Enter the name\n");
	scanf("%s",&array_name[i]);
	printf("Enter the salary\n");
	scanf("%f",&array_salary[i]);
	EXEC SQL insert into emp values(:array_id[i],:array_name[i],:array_salary[i]);
	}
	EXEC SQL COMMIT WORK RELEASE;
}




void retrieveMoreThanUsingCursor() {
	int count=5,i;
	EXEC SQL DECLARE emp_cursor CURSOR FOR
	select * from emp;

	EXEC SQL OPEN emp_cursor;

		for(i=0;i<count;i++){
	EXEC SQL FETCH emp_cursor into :id,:emp_name,:sal;
		
		printf("Id is %d, name is %s and salary is %f\n",id,emp_name,sal);
	}
	EXEC SQL CLOSE emp_cursor;
}

void retrieveUsingStructMoreRec() {
int i;
printf("Display all record using struct with cursor\n");


	EXEC SQL select count(*) into :numberOfRec from emp;

	EXEC SQL DECLARE emp_cursor1 CURSOR FOR select * from emp;

	EXEC SQL OPEN emp_cursor1;

		for(i=0;i<numberOfRec;i++){
			EXEC SQL FETCH emp_cursor1 into :emp_rec.s_id,:emp_rec.s_name,:emp_rec.s_salary;
			printf("Id is %d, name is %s and salary is %f\n",emp_rec.s_id,emp_rec.s_name,emp_rec.s_salary);
	}

	EXEC SQL CLOSE emp_cursor1;
}

void anonymousPlSQLBlock() {
	printf("Pl SQL Anonymous Block\n");
	printf("Enter the id\n");
	scanf("%d",&id);
	printf("Enter the name\n");
	scanf("%s",&emp_name);
	printf("Enter the salary\n");
	scanf("%f",&sal);
	EXEC sql EXECUTE
		BEGIN
			insert into emp values(:id,:emp_name,:sal);
			//select salary into :sal from emp where empid=:id;
		END;
	END-EXEC;
	EXEC SQL COMMIT WORK RELEASE;
}


void callStoreProcedureInParameter() {
	printf("Pl SQL Procedure Block\n");
	printf("Enter the id\n");
	scanf("%d",&id);
	printf("Enter the name\n");
	scanf("%s",&emp_name);
	printf("Enter the salary\n");
	scanf("%f",&sal);
	EXEC sql EXECUTE
		BEGIN
			empPro(:id,:emp_name,:sal);
		END;
	END-EXEC;
	EXEC SQL COMMIT WORK RELEASE;
}


void callStoreProcedureInOutParameter() {
	printf("Pl SQL Procedure Block In and Out parameter\n");
	printf("Enter the id\n");
	scanf("%d",&id);
	EXEC sql EXECUTE
		BEGIN 
		proEmpSal(:id,:emp_name);
		END;
	END-EXEC;
	printf("Employee salary from the stored procedure is %s\n",emp_name);
}


